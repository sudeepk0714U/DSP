clc; clear; close all;
x = input('Enter sequence x as a vector (e.g., [1 2 3]): ');
h = input('Enter sequence h as a vector (e.g., [4 5 6]): ');
Nx = length(x);
Nh = length(h);

% Edge case: sequences of unequal length
if Nx ~= Nh
    % Zero-padding the shorter sequence to match lengths
    N = max(Nx, Nh);
    x = [x zeros(1, N - Nx)];
    h = [h zeros(1, N - Nh)];
    fprintf('Sequences zero-padded to length %d for circular convolution.\n', N);
else
    N = Nx;  % lengths are equal
end

% Compute DFT of both sequences
X = fft(x, N);
H = fft(h, N);

% Multiply in frequency domain (circular convolution)
Y = X .* H;

% Compute IDFT to get circular convolution result
y = ifft(Y, N);

% Display result
disp('Circular convolution result using DFT/IDFT:');
disp(y);

% Plot sequences and convolution
figure;
subplot(3,1,1);
stem(0:N-1, x, 'filled');
title('Sequence x[n]');
xlabel('n'); ylabel('x[n]');
grid on;

subplot(3,1,2);
stem(0:N-1, h, 'filled');
title('Sequence h[n]');
xlabel('n'); ylabel('h[n]');
grid on;

subplot(3,1,3);
stem(0:N-1, real(y), 'filled'); % take real part to avoid tiny imaginary errors
title('Circular Convolution y[n] = x[n] âŠ› h[n]');
xlabel('n'); ylabel('y[n]');
grid on;
